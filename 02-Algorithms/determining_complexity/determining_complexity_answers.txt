1: What's the Big-O of the following algorithm? Submit your work and reasoning with your solution.

goodbye_world.rb
def goodbye_world(n)
 puts "Goodbye World! #{n}"
end

		O(1) because it's constant meaning it will always execute in the same amount of time.

2: What's the Big-O of the following algorithm? Submit your work and reasoning with your solution.

find_largest.rb
def find_largest(collection)
 largest = collection[0]
 collection.length.times do |i|
   if collection[i] >= largest
     largest = collection[i]
   end
 end
 largest
end

		O(n) as collection grows in size so does the number of operations find_largest executes also grows at the same rate.

3: What's the Big-O of the following algorithm? Submit your work and reasoning with your solution.

find_largest_2D_array.rb
def find_largest(collection)
 largest = collection[0][0]
 collection.length.times do |i|
   subcollection = collection[i]
   subcollection.length.times do |i|
     if subcollection[i] >= largest
       largest = subcollection[i]
     end
   end
 end
 largest
end

		O(n^2) quadratic time because for every size increase time to execute increases at the same rate.

4: What's the Big-O of the following algorithm? Submit your work and reasoning with your solution.

numbers_recurive.rb
def numbers(n)
 if (n == 0)
   return 0
 elsif (n == 1)
   return 1
 else
   return numbers(n-1) + numbers(n-2)
 end
end

		O(2^n) exponential time because as n grows execution time grows much faster due to recursive calling of numbers(n-1) + numbers(n-2).

5: What's the Big-O of the following algorithm? Submit your work and reasoning with your solution.

numbers_iterative.rb
def iterative(n)
 num1 = 0
 num2 = 1
 i = 0
 while i < n-1
   tmp = num1 + num2
   num1 = num2
   num2 = tmp
   i+=1
 end
 num2
end

		O(n) linear time.  As the size of n increases, execution time increases with it at the same rate.

6: What's the Big-O of the following algorithm? Submit your work and reasoning with your solution.

sort.rb
def sort(collection, from=0, to=nil)
 if to == nil
   # Sort the whole collection, by default
   to = collection.count - 1
 end

 if from >= to
   # Done sorting
   return
 end

 # Take a pivot value, at the far left
 pivot = collection[from]

 # Min and Max pointers
 min = from
 max = to

 # Current free slot
 free = min

 while min < max
   if free == min # Evaluate collection[max]
     if collection[max] <= pivot # Smaller than pivot, must move
       collection[free] = collection[max]
       min += 1
       free = max
     else
       max -= 1
     end
   elsif free == max # Evaluate collection[min]
     if collection[min] >= pivot # Bigger than pivot, must move
       collection[free] = collection[min]
       max -= 1
       free = min
     else
       min += 1
     end
   else
     raise "Inconsistent state"
   end
 end

 collection[free] = pivot

 sort collection, from, free - 1
 sort collection, free + 1, to

 collection
end

		O(nlogn) loglinear time.  As n grows execution and completion time grows faster than constant time but slower than loglinear time.